/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/
//#include <cmath>
#include <iostream>
#include <tchar.h>


#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

void debug_print_hex(int number){
	using namespace std;
	cout << hex << number << endl;
}

void new_line(){
	std::cout << std::endl;
}

void print_msg(char message[]){
	std::cout << message;
}

void println_msg(char message[]){
	std::cout << message << std::endl;
}

void print_line(){
	std::cout << "-------------------------------------------------------------" << std::endl;
}

void print_exersize_id(char id[]){
	print_line();
	std::cout << "Exercise #" << id << std::endl << std::endl;
}

int _tmain()
{
// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
		print_exersize_id("1.1b");
		int y;//Задайте значение y, например, с помощью потока ввода
		print_msg("Enter the integer: ");
		std::cin >> y;

	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)

		unsigned int mask = 0x80000000;
		int symbol_counter = 0;
		bool one_met = false;
		for (int i = 31; i >= 0; i--){
			int piece_of_y = y & mask;
			piece_of_y = piece_of_y >> i;
			if (piece_of_y == 0 && !one_met){

			}
			else
			{
				one_met = true;
				std::cout << (piece_of_y);
			}
			
			//binary_number[bin_num_counter] = zero_or_one(piece_of_y >> i);
			//bin_num_counter++;
			symbol_counter++;
			if (symbol_counter == 4){
				if (one_met)
					print_msg(" ");
				symbol_counter = 0;
			}
			mask = mask >> 1;
		}
		new_line();
	
	// б) пропустите незначащие нули -  1 0 0 1
		
	}
	

	//1.2 Дана целая переменная
	{
		print_exersize_id("1.2");
		int y;//Задайте значение y, например, с помощью потока ввода
		print_msg("Enter an integer: ");
		std::cin >> y;
		//"Сдвиньте" все единицы в сформированном значении вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
		int new_number = 0;
		for (int i = 31; i >= 0; i--){
			int y_bit = y >> i;
			if (y_bit > 0){
				new_number = (new_number << 1) | 1;
			}
		}
		std::cout << std::hex << new_number << std::endl;
	}


	//1.3 Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
	short sNum = 0x8008;
	short sRes;

	//0x7ff7
	sRes = ~sNum;
	//0x8ff8
	sRes = sNum | 0x0ff0;
	//0x0008
	sRes = static_cast<unsigned short>(sNum) >> 12;
	//0x7f08
	sRes = sNum ^ 0xff00;
	//0xf001
	sRes = sNum >> 3;
	//0x0010
	sRes = static_cast<unsigned short>(sNum) >> 11;
	}

	stop
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
#define _USE_MATH_DEFINES
#include <math.h>
	{
		//??? Как включить cmath, чтобы константы из math.h были доступны ???
		using namespace std;
		print_exersize_id("2");
		cout << "Enter the radius of circle: ";
		double radius = 0.0;
		cin >> radius;
		cout << "Circumference = " << radius * 2 * M_PI << endl;	
	}

	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
		#define LENGTH(length) (static_cast<float>(length)*2*M_PI)
		using namespace std;
		float l1 = LENGTH(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGTH(2); // должно быть 0.07957...
		#undef LENGTH
	}

	//2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	#define MAX(A, B) (A > B ? A : B)
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно

	int i = 10, j = 12, k;
	k = MAX(i, j);			//k == 12 (j)
	k = MAX(j, i) * 2;		//k == 24 (j*2)
	k = MAX(j, i+3);		//k == 13 (i + 3)
	k = MAX(i--, j++);		//k == 13 (i) - постфиксные операции инкремента/декремента	
	/* Исправление
	k = MAX(--i, ++j);
	*/
#undef MAX 

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	#define EXCHANGE(x, y) do{ int temp = x; x = y; y = temp;}while(0);

	int x1=1, y1=-1;
	EXCHANGE(x1, y1);

	int x2=100, y2=-100;
	EXCHANGE(x2, y2);

	int i3 = 1;
	double d3 = 2;
	EXCHANGE(i3, d3);	//Неявное приведение типов

	#undef EXCHANGE


	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

int iNN;
/* iNN = 0;
#define NNN
#define MMM
*/

/* iNN = 1;
#define MMM
*/

/* iNN = 2;
#define NNN
*/

#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;
#else
	iNN = -1;
#endif
	std::cout << iNN << std::endl;
	
	stop

		//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
		//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
		//В опциях командной строки в зависимости от мишени сборки проекта
		//(Debug или Release) может быть определено с помощью ключа /D
		//имя _DEBUG. С помощью директив условной
		//трансляции напишите фрагмент кода, который в зависимости от типа
		//мишени выводит с помощью cout разный текст на консоль. Проверьте
		//при разных мишенях сборки.
#if defined _DEBUG 
	println_msg("Debug configuration!");
	std::cout<<__FILE__<<std::endl;
	std::cout << std::dec << __LINE__ << std::endl;
	std::cout<<__TIME__<<std::endl;
#else
		println_msg("Release configuration!");
#endif

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//???????имени файла, номере строки с (?) функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros

	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration


	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.
	{
		//#define _UNICODE
#undef _UNICODE
#ifdef _UNICODE
		typedef wchar_t my_char;
#else
		typedef char my_char;
#endif
		my_char c = 'a';
		using namespace std;
		cout << sizeof(c) << endl;
	}
// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
{
#if defined _DEBUG
#include "1.h"
#else
#include "2.h" 
#endif
	print_exersize_id("3.1");
	using namespace std;
	MyEnum first = My1;
	MyEnum second = My2;
	MyEnum third = My3;
	cout << "My1 == " << first << endl;
	cout << "My2 == " << second << endl;
	cout << "My3 == " << third << endl;
}

// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
	{
		char chr = 'a';
		short sht = 10;
		int integer = 1000;
		float flt = 10.2F;
		double dbl = 13.24;

		char *chr_ptr = &chr;		//-> адрес chr			chr_ptr	0x0048fbe7 "aММММММММ\x2"	char *
		short *sht_ptr = &sht;		//-> адрес sht			sht_ptr	0x0048fbd8 {10}	short *
		int *int_ptr = &integer;	//-> адрес integer 		int_ptr	0x0048fbcc {1000}	int *
		float *flt_ptr = &flt;		//-> адрес flt			flt_ptr	0x0048fbc0 {10.1999998}	float *
		double *dbl_ptr = &dbl;		//-> адрес dbl			dbl_ptr	0x0020fa98 {13.240000000000000}	double *
	}
	


	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	char sm_word_string[] = "some word";
	char *sm_wrd = sm_word_string;
	char sm_let_1 = sm_wrd[5]; // w
	//char *sm_wrd_2 = &sm_word_string; - присвоить строковое значение по адресу нельзя
	stop



	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3};				//Address of nAr: 	0x0038f998 	value: {1, 3, 0}
		int* pn = &nAr[0];				//Address of pn: 	0x0038f998 	value: {1}
		(*pn)++;						//Address of pn: 	0x0038f998 	value: {2} value of nAr: {2,3,0}
		pn++;							//Address of pn: 	0x002bf6c4 	value: {3}	--> это адрес второго элемента массива

		char cAr[]={'A','B','C','D'};	//Address of cAr: 	0x002bf6a8 	value: "ABCD...	char[4]
		char* pc = &cAr[0];				//Address of pc:	0x0032fa50  value: "ABCDММММММММlъ2"
		(*pc)=(*pc)+5;					//Address of pc:	0x0032fa50 	value: "FBCDММММММММlъ2"
										// указывает на начало массива
		pc=pc+3;						//Address of pc:	0x0032fa53 	value: "DММММММММlъ2"
										// указывает на третий элемент массива	
	
		double dAr[3]={1.0,2.0};		//Address of dAr:	0x0032fa24 	value: {1.00, 2.00, 0.00}
		double* pd1 = &dAr[0];			//Address of pd1:	0x0032fa24 {1.00}			
		double* pd2 = pd1;				//Address of pd2:	0x0032fa24 {1.00}			
		(*pd2)+=2;						//Address of dAr: 	0x0032fa24 {3.00, 2.00, 0.00}
										//Address of pd1:	0x0032fa24 {3.00}
										//Address of pd2:	0x0032fa24 {3.00}
		pd2+=2;							//Address of pd2:	0x0032fa34 {0.00}

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];					//Address of pd1:	0x0049f66c 	value: {3.00}
										//Address of dAr:	0x0049f66c value: {3.00, 2.00, 0.00}
		pd2 = &dAr[1];					//Address of pd2:	0x0049f674 	value: {2.00}
		int nNumber=pd2 - pd1;			//nNumber == 1
										//В данном случае, этот результат показывает на сколько элементов друг от друга находятся эти переменные

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		print_exersize_id("5.5");
		if (pd1 > pd2){
			using namespace std;
			cout << "pd1 > pd2" << endl;
		}
		else if (pd2 > pd1){
			using namespace std;
			cout << "pd2 > pd1" << endl;
		}else{
			using namespace std;
			cout << "pd1 == pd2" << endl;
		}

		stop
	}


	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	////pucObject5	0x002cf808 "€wfUММММММММ\x1"	unsigned char *
	char cc = *(pucObject5++);	//cc	0x88 '€'	char
								//pucObject5	0x002cf809 "wfUММММММММ\x1"	unsigned char *
	cc = (*pucObject5)++;		//cc	0x77 'w'	char
								//pucObject5	0x002cf809 "xfUММММММММ\x1"	unsigned char *
	cc = ++*(pucObject5);		//cc	0x79 'y'	char
								//pucObject5	0x002cf809 "yfUММММММММ\x1"	unsigned char *
	cc = *(++pucObject5);		//cc	0x66 'f'	char
								//pucObject5	0x002cf80a "fUММММММММ\x1"	unsigned char *
	stop


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3;	// 5	
	pVoid=&cObject3;	// 'A'	
	pVoid=pInt;			// 5	
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		const void* v_ptr = &n;//объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) Присваивается только часть адреса
	stop

		//Задание 8. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель
		int i_value_2 = 1000;
		//Задание 8a. Указатель является константой. 
		int i_value = 10;
		int* const i_ptr = &i_value;
		*i_ptr = 100;
		//i_ptr = &i_value_2; - нельзя модифицировать - неизменяемый указатель
		stop


			//Задание 8б. Указываемое значение является константой.
		const int i_const_value = 12;
		const int* i_ptr_2 = &i_const_value;
		//*i_ptr_2 = 120; - значение переменной константное, изменить нельзя
		i_ptr_2 = &i_value_2;
		stop


			//Задание 8в. И указатель, и указываемое значение
			//являются константами. 
		const int* const i_ptr_3 = &i_const_value;
		//*i_ptr_3 = 120;
		//i_ptr_3 = &i_value_2;
		stop


		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
		const int nN = 1;

		//Объявите указатель и проинициализируйте его выражением - &nN	
		const int* nN_ptr = &nN;
	stop



	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1
	int* pn = &n1;


    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn
	int** ppn = &pn;

    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn
	int*** pppn = &ppn;
  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	int n2 = *pn;
	n2 = **ppn;
	n2 = ***pppn;
  
	stop



	system("pause");
	return 0;
}//end main
