
/*
В результате выполнения данной работы слушатель получает много мелких но необходимых
для дальнейшей работы навыков, поэтому задание построено как последовательность
закомментированных блоков, которые требуется последовательно раскомментировать,
отвечая  при этом на поставленные вопросы.

Примерная последовательность действий при отладке проекта:
1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
Замечание: этот этап явно вызывать необязательно, но полезно для начинающего
программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
(warnings), возникающие при компиляции данного конкретного файла;
3. скомпонуйте проект(Build/Build ***.exe или F7)
Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к.
позволяет перекомпилировать только измененные файлы и в случае отсутствия
ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что
исполняемый код будет содержать информацию для отладчика -
(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или
просто кликните левой кнопкой на левой серой полосе окна редактирования;
5. запустите программу в режиме отладки
(Debug/Start... или  F5);

Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие
пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с
помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода
using namespace std;

int nTwin = 1;			//глобальная переменная
namespace TwinSpace{ int nTwin = 2; }	//переменная объявлена в
//пространстве имен - TwinSpace

#define	  stop __asm nop	//с помощью макроподстановки задаем "пустую" команду.
//Эта макроподстановка нужна только для того, чтобы
//можно было поставить на этой строке точку останова.

void exercise_print(char number[]){
	cout << "-------------------------------------------------------------------" << endl
		<< "Exercize " << number << endl << endl;
}

//Функция для задания 9.1
int sum_the_interval(int low, int limit){
	int sum = 0, current_number = low;
	for (int i = low; i <= limit; i++){
		sum += current_number;
		current_number++;
	}
	return sum;
}

int main()
{

	//**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байтов, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.


	char cByte = 'A';				//0xcc 'M' not init
	cByte = 0x42;					//0x41 'A'
	cByte = 66;						//0x42 'B'
	cByte = -1;						//0x42 'B'
									//cByte == [0xff (dec: -1)]
	unsigned char ucByte = 0x41;    //ucByte == 0xcc'M'
	ucByte = 'B';					//0x41 'A'
	ucByte = -1;					//0x42 'B'
									//ucByte = 0xff (dec: 255)
	int iInt = 0xffffffff;			//0xcccccccc - not init
									//iInt: 0xffffffff	(dec: -1)
	unsigned int uiInt = 0xffffffff;//uiInt: 0xcccccccc	not init
									//uiInt	dec: 4294967295	
	float fFloat = 1.f;				//fFloat == -107'374'176.
									//fFloat == 1.00000'000
	double dDouble = 1.;			//dDouble == -9.255'963'134'931'783'1e+061
									//dDouble == 1.000'000'000'000'000'0
	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789;	//реальное значение - 0.12345'67890'12345'68, 
	//компилятор округлил значение, т.к.
	//в типе double может быть от 15 до 17 знаков после запятой,
	//в зависимости от ОС
	//значение же иницизатора имеет 28 знаков после запятой

	float  f = 0.1234567890123456789123456789;	//реальное значение - 0.12345679
	//максимальное количество знаков после запятой для данного типа - 6

	d = 1.;										//Заносится 1, т.к. после . значение 0

	d = 0.999999999999999999999999999999999;	//Заносится 1, так как количество чисел после . 
	//значения инициализатора превышает допустимое 
	//для типа double количество цифр.
	//Поэтому значения округляется до 1

	stop

		// В комментариях напишите результат, возвращаемый оператором sizeof для
		// переменной типа wchar_t (ее размер)
		wchar_t cw = L'Ф'; //0x0424
	size_t n = sizeof(cw); //Возвраещается результат равный 2-м байтам
	stop


		// **************************************************************
		//Задание 2a. Неявное приведение типов данных.
		//Объясните разницу результата при выполнении (1) и (2):
		//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

		iInt = 1;
	double dDouble1 = iInt / 3;		// (1) Результат: 0 
	//double dDouble2 = static_cast<double>(iInt / 3.);
	// справа от знака присваивания результат выражения имеет тип int,
	// у которого не может быть чисел после запятой,
	// соответственно то, что могло быть за знаком . теряется.

	double dDouble2 = iInt / 3.;	// (2) Результат: 0.333333
	//double dDouble2 = static_cast<double>(iInt) / 3.;
	// делитель (3.) является представителем типа double,
	// поэтому всё выражение (1/3.) приводится к этому типу.



	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	(dDouble = (fFloat = (iInt = (sShort = (cByte = (3.3 / 3))))));			// (1)
	//warning C4244 : '=' : conversion from 'double' to 'char', possible loss of data
	//Предупреждает нас о том, что когда мы присваиваем double к char, мы можем потерять данные

	//warning C4244: '=' : conversion from 'int' to 'float', possible loss of data
	//т.к. в 64-х битных системах тип int может содержать больше байт данных, нежели тип float,
	//компиллятор предупреждает нас о возможной потере данных

	(cByte = (sShort = (iInt = (fFloat = (dDouble = (3.3 / 3))))));			// (2)
	//warning C4244: '=' : conversion from 'double' to 'float', possible loss of data
	//приведение типа float к типу double может привести к потере данных, 
	//т.к. тип double имеет размер 8 байт а float 4.
	//warning C4244: '=' : conversion from 'float' to 'int', possible loss of data
	//приведение типа float к типу int может привести к потере данных, так как
	//тип float может иметь числа после запятой, а int нет
	//warning C4244: '=' : conversion from 'short' to 'char', possible loss of data
	//тип short имеет размер 2 байта, а тип char имеет размер 1 байт, 
	//следовательно, может быть потеря данных


	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt = 257;		// 0x101
	cByte = iInt;	// 257 в двоичном исчислении это 0001'0000'0001
	// мы приводим число к типу char, который может содержать только 1 байт
	// следовательно 0001' - отсекается
	// остаётся только 0000'0001 (1)

	unsigned char cN1 = 255, cN2 = 2, cSum;
	cSum = cN1 + cN2;	//максимальное значение для беззнакового char в десятичном формате == 255
	//мы прибавляем к нему 2, и получаем 257
	//=> мы получаем в двоичном формате 0001'0000'0001
	//0001 - отсекается, остаётся 0000'0001

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1 + cN2;		//Сумма двух переменных типа char формирует число, выходящее за пределы
	//размерности типа char.
	//по идее к iSum должна была прийти только 1,
	//но судя по коду ассеблера, присваивается всё значение равное 257
	/*
	00CF9375  movzx       eax,byte ptr [cN1]	; в регистр eax записывается значение cN1 == 255
	00CF937C  movzx       ecx,byte ptr [cN2]	; в регистр ecx записывается значение cN2 == 2
	00CF9383  add         eax,ecx				; суммируется 255 + 2 = 257, в регистре eax находится 4 байта =>
	; в eax находится:
	; 0000'0000 0000'0000 0000'0001 0000'0001
	00CF9385  mov         dword ptr [iSum],eax	; к iSum присваивается значение из eax, т.е. iSum == 257
	*/

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1 = 0xff, c2 = 2;
	unsigned char uc1 = 0xff, uc2 = 2;
	int iSum1 = c1 + c2;		//(1)
	//в этом случае результат равен 1, потому что
	//знаковые переменные типа char имеют значения
	//с1 == -1
	//c2 == 2
	//их сумма == 1
	int iSum2 = uc1 + uc2;	//(2)
	//в этом случае uc1 = 255 (беззнаковый тип)
	//=> 255 + 2 = 257
	stop


		// ***********************************************************
		//Задание 2b. Явное приведение типов данных.
		//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
		// Напишите явно преобразования, которые неявно выполняет компилятор
		int nTmp = 100, nn = 3;
	dDouble = 3.3 + nTmp / nn;	// (3)
	// Сначала компилятор выполнит выражение nTmp / nn, которое равно 33
	// так как это обе переменные типа int, дробная часть не сохраняется
	// Далее компилятор сложет предыдущий резульат с 3.3.
	// В этом случае выражение приводится к старшему типу double
	// и мы получаем, в итоге, 36.3

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа

	double dDouble3 = static_cast<double>(nTmp) / nn + 3.3;

	stop


		// *******************************************************
		// Задание 3. Область действия, область видимости и
		//				время существования переменных

		//   В этом фрагменте фигурируют четыре переменных с одним и тем же именем 
		//		nTwin - одна глобальная, 
		//		вторая определена в своем пространстве имен, 
		// (определены выше в начале модуля) 
		//		третья - локальная внутри функции main(), 
		//		четвертая - вложенная локальная внутри блока. 
		//   В данном задании требуется в выделенных местах фрагмента определить, к какой 
		// из четырех переменных идет обращение, а также факт существования и видимости 
		// для всех четырех, заполнив приведенные в задании таблицы 
		//	Для выполнения задания рекомендуется пользоваться окнами "Locals" и "Watches"
		// Подсказка: - в окно "Watches" можно поместить как nTwin
		//			так и ::nTwin, впрочем как и TwinSpace::nTwin


		nTwin = 100;			//глобальная							100
	TwinSpace::nTwin = 300;		//определена в своем пространстве имен	300
	nTwin++;					//глобальная							101
	// Обратите внимание на небольшой "глюк" отладчика. Хотя локальная переменная nTwin
	// до следующей строки еще не определена (и формально даже не существует), но место
	// под нее в стеке функции main уже выделено (и там мусор). Если теперь в  окно 
	// "Watches" поместить просто nTwin, то отладчик будет показывать значение этой, еще 
	// не объявленной локальной переменной (что-то вроде -858993460 или 0xcccccccc), 
	// хотя должен формально показывать значение глобальной переменной, объявленной ранее.
	// Компилятор при этом все вычисляет верно.
	// Если надо увидеть именно значение глобальной переменной, то надо явно указать в окне
	// "Watches" глобальную область видимости, т.е. написать там ::nTwin.
	// Примечание: вот еще один аргумент за то, чтобы не создавать конфликты имен.
	int nTwin;					//локальная внутри функции main()		0xcc
	nTwin = 200;				//локальная внутри функции main()		200	
	::nTwin++;					//глобальная							102			
	{
		int nTwin;				//вложенная локальная внутри блока		0xcc
		nTwin = -1;				//вложенная локальная внутри блока		-1
		::nTwin++;				//глобальная							103
		TwinSpace::nTwin++;		//определена в своем пространстве имен	301
	}

	nTwin--;					//локальная внутри функции main()		199


	// *******************************************************
	// Задание 4. Спецификатор класса памяти - static
	// а) Для каждой итерации цикла напишите значения пременных nLocal# и nStatic#.
	// б) Напишите, когда выполняется инициализация обеих переменных?
	// в) Поясните (в комментарии) разницу между способом инициализации 
	//     переменных nStatic1 и nStatic2 и поясните побочный эффект, 
	//     влияющий на переменную nLocal2.

	for (int i = 0; i<3; i++)					//			:	ITERATIONS
	{											//	VAR		:	1		2		3	
		static int nStatic1 = 100;				//	nStatic1:	100		(101)	(102)
		int nLocal1 = 100;						//	nLocal1	:	100		100		100
		int nLocal2 = 200;						//	nLocal2	:	200		200		200
		static int nStatic2 = nLocal2++ * 2;	//	nStatic2:	400		402		404								
		nStatic1++;								//	nStatic1:	101		102		103
		nStatic2++;								//	nStatic2:	401		402		403	
		nLocal1++;								//	nLocal1	:	101		101		101		
		//  nLocal2	:	201		200		200
		stop

	}
	// Напишите:
	//   а) как изменилось поведение пременной nStatic1?
	//   б) как эта переменная ИНИЦИАЛИЗИРОВАНА ?
	for (int i = 0; i<3; i++)
	{
		static int nStatic1;	//i == 0 : Переменная не проинициализирована
		//i == 1 : Игнорирование инициализации			nStatic = 101
		//i == 2 : Игнорирование инициализации			nStatic = 101
		nStatic1 = 100;			//i == 0 : Переменная проинициализирована,		nStatic = 100
		//i == 1 : Переменной присвоено значение 100	nStatic = 100
		//i == 2 : Переменной присвоено значение 100	nStatic = 100
		int nLocal1 = 100;
		nStatic1++;				//i == 0 : инкремент => nStatic = 101
		//i == 1 : инкремент => nStatic = 101
		//i == 2 : инкремент => nStatic = 101
		nLocal1++;
		stop

	}



	// *******************************************************
	// Задание 5. Перечисления - enum
	// Обратите внимание на явную и неявную инициализацию констант
	// Выполняя задание по шагам, следите за значениями, которые
	// принимает переменная myColors


	enum eColors
	{							//	int
		BLACK,					//	0
		BLUE,					//	1
		GREEN,					//	2
		RED = 5,				//	5
		YELLOW,					//	6
		WHITE = RED + 4			//	9
	};



	eColors   myColors;	//объявление переменной типа eColors 
	myColors = BLACK;
	myColors = BLUE;
	myColors = GREEN;
	myColors = RED;
	myColors = YELLOW;
	myColors = WHITE;

	int nnn = BLACK;	//любой целочисленной переменной можно присвоить
						//значение из списка инициализирующих значений

	//Именованные константы можно использовать в выражениях:
	nnn = BLUE | YELLOW;

	//Раскомментируйте следующую строку и обратите
	//внимание на  ошибку при компиляции 
	myColors = static_cast<eColors>(1);	//модифицируйте выражение таким образом, чтобы компилятор не выдывал ошибки

	// Выполните следующее присваивание НЕ меняя перечисление и тип переменной myColors?
	myColors = static_cast<eColors>(123);
	stop


		// *******************************************************
		// Задание 6.1 Логический тип bool
		// Выполняя задание по шагам, следите за значениями
		// переменной b и интерпретируйте результат. Напишите эти значения в комментариях

		int nNumber = 1;
	bool b = (nNumber != 0);	//true	1
	b = (nNumber == 0);			//false 0
	b = (nNumber > 0);			//true	1
	b = (nNumber > 1);			//false 0
	b = 5;						//true	1

	//Вы всегда можете преобразовать логическое значение к целому
	//явно или компилятор может это сделать самостоятельно (неявно)
	//Обратите внимание: как интерпретирует значения логических переменных компилятор?
	int tmp = b + 1;			//	2

	//Задание 6.2 В Григорианском календаре (которым мы все пользуемся) високосный год
	// определяется по следующему алгоритму: високосным является каждый четвертый год,
	// но каждый сотый високосным не является, при этом каждый 400-й год все таки 
	// високосный. Т.е. 1823 - не високосный, 1824 - високосный, 1900 - не високосный,
	// 2000 - високосный.
	// Напишите фрагмент кода, такой что:
	// логическая переменная isLeapYear принимает значение true, если год, заданный
	// переменной year - високосный.
	// Примечание: НЕ НАДО пользоваться операторами if-else, тернарным оператором и switch
	//             НАДО написать логическое выражение в одну строку.
	{
		//Примеры задания года для проверки:  1823, 1900 - не високосные, 1824, 2000 - високосные

		//Вычислили значение 
		int year = 1823;
		bool isLeapYear = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
		// проверили значение в отладчике
		stop
	}

	// *******************************************************
	// Задание 7. Модификатор const и переменные

	{
		//Раскомментируйте следующие две строчки и объясните (в комментариях)
		//ошибки при компиляции 

		//	const int nN;	// nN - Константа
		//	nN = 1;			// Константе нельзя присваивать значение
	}



	// ********************************************************
	//Задание 8. Логические условные операторы и операторы отношения.

	//Задание 8.1 Напишите фрагмент кода, который переводит код символа, 
	//хранящийся в переменной ch в противоположный регистр.
	//Требуется предусмотреть проверку ситуации, когда пользователь ввел цифру
	//или нажал другую клавишу, которой символ не соответствует
	//Подсказка: работаем только с символами английского алфавита, для которого в таблице
	// кодов ASCII код каждой буквы нижнего регистра на 0x20 больше кода 
	// соответствующей буквы верхнего регистра.
	exercise_print("8.1");
	{
		// Сформируйте значение переменной ch с помощью потока ввода
		char ch;
		cout << "Enter latin letter to convert it: ";
		cin >> ch;
		if (ch > 96 && ch < 123){
			ch -= 32;
		}
		else if (ch > 40 && ch < 91){
			ch += 32;
		}
		else{
			cout << "It's possible to convert only latin letters" << endl;
		}
		cout << ch << endl;
		//... изменили регистр
		// здесь проверили в отладчике значение или вывели "эхо" на экран
		stop
	}


	//Задание 8.2 Напишите фрагмент кода, который реализует с помощью if (if/else)
	//следующую логику: если x меньше или равен 0, y=0
	//если x больше 0 но меньше 1, то y=x,
	//если x больше или равен 1, то y=1
	//Подумайте: какого типа должны или могут быть x и y?
	{
		double x, y;				//Так же могут быть типа float, long double
		if (x <= 0){
			y = 0;
		}
		else if ( x < 1)
		{
			y = x;
		}
		else {
			y = 1;
		}
	}

	//Задание 8.3 Напишите фрагмент кода, который реализует с помощью switch
	//следующую логику: в переменной cInput типа char дано значение символа,
	//введенного любым способом.
	//Если введен символ 'y' (т.е. yes) в любом регистре, то присвоить
	//переменной у значение переменной x
	//Если введен символ 'n' (т.е. no) в любом регистре, то присвоить
	//переменной у значение (x * 2)
	//Если любой другой симол, то вывести сообщение об ошибке
	exercise_print("8.3");
	{
		int x = 60, y = 2;
		char ch;
		cout << "Enter y/n to see result: ";
		cin >> ch;
		switch (ch)
		{
		case 'y':
		case 'Y':
			y = x;
			break;
		case 'n':
		case 'N':
			y = x * 2;
			break;
		default:
			cout << "ERROR" << endl;
			break;
		}
		cout << "y = " << y << endl;
		//сформировали значение
		//switch
	}
	// ********************************************************
	//Задание 9. Циклы.

	//Задание 9.1 Напишите фрагмент кода, который реализует с помощью for
	//следующую логику: найти сумму заданного диапазона целых чисел.
	//Введите границы с помощью потока ввода или с помощью средств отладки.
	//Предусмотрите защиту от ввода нижней границы больше, чем верхней.
	exercise_print("9.1");
	{
		//сформироыать границы диапазона
		int low, limit;
		bool right_entry = false;
		while (!right_entry)
		{
			cout << "Please, enter the low boarder of numbers interval: ";
			cin >> (int)low;
			cout << "Please, enter the high limit of numbers interval: ";
			cin >> (int)limit;
			if (low > limit){
				cout << "ERROR: wrong numbers";
			}
			else
			{
				right_entry = true;
			}
		}
		cout << "The sum of [" << low << ", " << limit << "] interval is " << sum_the_interval(low, limit) << endl;



		//проверить корректность значений

		// вычислить сумму
		// проверить в отладчике значение
		stop
	}


	//Задание 9.2 Напишите фрагмент кода, который реализует с помощью do-while
	//следующую логику: на каждой итерации цикла ввести с консоли целое значение
	// и покинуть цикл, если значение удовлетворяет условию: 
	// значение больше или равно 10 и четное.
	//Замечание: проверка на четность с использованием операции остатка от деления
	//нацело генерирует очень неэффективный код. Попробуйте реализовать альтернативный
	//вариант.
	exercise_print("9.2");
	int x = 0;
	do{
		x++;
	} while (!((x >= 10) && ((x & 1) == 0)));
	cout << "Out of \"while-loop\"." << endl
		<< "x = " << x << endl;

	//Задание 9.3 Напишите фрагмент кода, который реализует с помощью while
	//следующую логику: исходно int x = 0; 
	//на каждой итерации x=x+1, sum=sum+1/x
	//найти значение x, при котором sum>1.7
	exercise_print("9.3");
	x = 0;
	double sum = 0;
	while (sum * 10 <= 17)
	{
		x++;
		sum = sum + 1 / static_cast<double>(x);
	}
	cout << "Out of \"while-loop\"" << endl
		<< "x = " << x << endl
		<< "sum = " << sum << endl;

	system("pause");
	return 0;//код завершения приложения
}	// Конец функции main()

